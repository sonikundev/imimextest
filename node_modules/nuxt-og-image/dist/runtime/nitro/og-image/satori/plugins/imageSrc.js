import { withBase } from "ufo";
import sizeOf from "image-size";
import { defineSatoriTransformer } from "../utils.js";
import { toBase64Image } from "../../../../pure.js";
import { useNitroOrigin, useStorage } from "#imports";
async function resolveLocalFilePathImage(publicStoragePath, src) {
  const key = `${publicStoragePath}${src.replace("./", ":").replace("/", ":")}`;
  if (await useStorage().hasItem(key))
    return await useStorage().getItemRaw(key);
}
export default defineSatoriTransformer([
  // fix <img src="">
  {
    filter: (node) => node.type === "img" && node.props?.src,
    transform: async (node, { e, publicStoragePath }) => {
      const src = node.props.src;
      const isRelative = src.startsWith("/");
      let dimensions;
      let imageBuffer;
      if (isRelative) {
        if (import.meta.prerender || import.meta.dev) {
          imageBuffer = await resolveLocalFilePathImage(publicStoragePath, src);
        } else {
          imageBuffer = await e.$fetch(src, {
            baseURL: useNitroOrigin(e),
            responseType: "arrayBuffer"
          }).catch(() => {
          });
        }
        if (imageBuffer)
          node.props.src = toBase64Image(imageBuffer);
      } else if (!src.startsWith("data:")) {
        imageBuffer = await $fetch(src, {
          responseType: "arrayBuffer"
        }).catch(() => {
        });
      }
      if (imageBuffer && (!node.props.width || !node.props.height)) {
        try {
          const imageSize = sizeOf(imageBuffer);
          dimensions = { width: imageSize.width, height: imageSize.height };
        } catch (e2) {
        }
        if (dimensions?.width && dimensions?.height) {
          const naturalAspectRatio = dimensions.width / dimensions.height;
          if (node.props.width && !node.props.height) {
            node.props.height = Math.round(node.props.width / naturalAspectRatio);
          } else if (node.props.height && !node.props.width) {
            node.props.width = Math.round(node.props.height * naturalAspectRatio);
          } else if (!node.props.width && !node.props.height) {
            node.props.width = dimensions.width;
            node.props.height = dimensions.height;
          }
        }
      }
      if (typeof node.props.src === "string" && node.props.src.startsWith("/")) {
        if (imageBuffer) {
          node.props.src = toBase64Image(imageBuffer);
        } else {
          node.props.src = `${withBase(src, `${useNitroOrigin(e)}`)}?${Date.now()}`;
        }
      }
    }
  },
  // fix style="background-image: url('')"
  {
    filter: (node) => node.props?.style?.backgroundImage?.includes("url("),
    transform: async (node, { e, publicStoragePath }) => {
      const backgroundImage = node.props.style.backgroundImage;
      const src = backgroundImage.replace(/^url\(['"]?/, "").replace(/['"]?\)$/, "");
      const isRelative = src?.startsWith("/");
      if (isRelative) {
        if (import.meta.prerender || import.meta.dev) {
          const imageBuffer = await resolveLocalFilePathImage(publicStoragePath, src);
          if (imageBuffer) {
            const base64 = toBase64Image(Buffer.from(imageBuffer));
            node.props.style.backgroundImage = `url(${base64})`;
          }
        } else {
          node.props.style.backgroundImage = `url(${withBase(src, `${useNitroOrigin(e)}`)}?${Date.now()})`;
        }
      }
    }
  }
]);

import { defineNuxtModule, createResolver, useLogger, installModule, hasNuxtModule, addPlugin, addImports, addServerHandler } from '@nuxt/kit';
import { colors } from 'consola/utils';
import { installNuxtSiteConfig } from 'nuxt-site-config-kit';
import { readPackageJSON } from 'pkg-types';
import { $fetch } from 'ofetch';

const Modules = [
  "@nuxtjs/robots",
  "@nuxtjs/sitemap",
  "nuxt-og-image",
  "nuxt-schema-org",
  "nuxt-seo-experiments",
  "nuxt-link-checker"
];
const module = defineNuxtModule({
  meta: {
    name: "nuxtseo",
    compatibility: {
      nuxt: ">=3.7.0",
      bridge: false
    },
    configKey: "seo"
  },
  defaults(nuxt) {
    return {
      enabled: true,
      debug: nuxt.options.debug,
      redirectToCanonicalSiteUrl: false,
      splash: false,
      // nuxt.options.dev, - figure out a solution for this in the future
      automaticDefaults: true,
      fallbackTitle: true
    };
  },
  async setup(config, nuxt) {
    const { resolve, resolvePath } = createResolver(import.meta.url);
    const { name, version } = await readPackageJSON(resolve("../package.json"));
    const logger = useLogger(name);
    logger.level = config.debug ? 4 : 3;
    if (config.enabled === false) {
      logger.debug("The module is disabled, skipping setup.");
      return;
    }
    await installNuxtSiteConfig();
    for (const module of Modules)
      await installModule(await resolvePath(module));
    if (config.automaticDefaults) {
      if (hasNuxtModule("@nuxtjs/i18n")) {
        addPlugin({
          src: resolve(`./runtime/nuxt/plugin/defaultsWaitI18n.server`),
          mode: "server"
        });
        addPlugin({
          src: resolve(`./runtime/nuxt/plugin/defaults`),
          mode: "client"
        });
      } else {
        addPlugin({
          src: resolve(`./runtime/nuxt/plugin/defaults`)
        });
      }
    }
    if (config.fallbackTitle) {
      addPlugin({
        src: resolve("./runtime/nuxt/plugin/titles")
      });
    }
    if (!hasNuxtModule("@nuxtjs/i18n")) {
      addImports({
        from: resolve(`./runtime/nuxt/composables/polyfills`),
        name: "useI18n"
      });
    }
    addImports({
      from: resolve(`./runtime/nuxt/composables/useBreadcrumbItems`),
      name: "useBreadcrumbItems"
    });
    const polyfills = {
      schemaOrg: ["useSchemaOrg", "defineWebSite", "defineWebPage"]
    };
    for (const [module, composables] of Object.entries(polyfills)) {
      if (nuxt.options[module]?.enable === false) {
        composables.forEach((name2) => {
          addImports({
            from: resolve("./runtime/nuxt/composables/polyfills"),
            name: name2
          });
        });
      }
    }
    nuxt.options.experimental.headNext = true;
    if (!nuxt.options.dev && config.redirectToCanonicalSiteUrl) {
      addServerHandler({
        handler: resolve("./runtime/nitro/middleware/redirect"),
        middleware: true
      });
    }
    if (config.splash && !version.includes("rc") && nuxt.options.dev) {
      logger.log("");
      let latestTag = `v${version}`;
      latestTag = (await $fetch("https://ungh.unjs.io/repos/harlan-zw/nuxt-seo/releases/latest", {
        timeout: 2e3
      }).catch(() => {
        return { release: { tag: `v${version}` } };
      })).release.tag;
      const upToDate = latestTag === `v${version}`;
      logger.log(`${colors.green("Nuxt SEO")} ${colors.yellow(`v${version}`)} ${colors.gray(`by ${colors.underline("@harlan_zw")}`)}`);
      if (!upToDate)
        logger.log(`${colors.gray("  \u251C\u2500 ")}\u{1F389} New version available!${colors.gray(` Run ${colors.underline(`npm i @nuxtjs/seo@${latestTag}`)} to update.`)}`);
      logger.log(colors.dim("  \u2514\u2500 \u{1F9EA} Help get Nuxt SEO stable by providing feedback https://github.com/harlan-zw/nuxt-seo/discussions/108"));
      logger.log("");
    }
  }
});

export { module as default };

import { pathToFileURL } from 'node:url';
import { createUnplugin } from 'unplugin';
import { transform } from 'unplugin-ast';
import { parseURL, parseQuery } from 'ufo';
import { createContext, runInContext } from 'node:vm';
import { resolveMetaKeyType, resolveMetaKeyValue, resolvePackedMetaObjectValue } from '@unhead/shared';
import MagicString from 'magic-string';
import { findStaticImports, parseStaticImport } from 'mlly';

function RemoveFunctions(functionNames) {
  return {
    onNode: (node) => node.type === "CallExpression" && node.callee.type === "Identifier" && functionNames.includes(node.callee.name),
    transform() {
      return false;
    }
  };
}
const TreeshakeServerComposables = createUnplugin((options = {}) => {
  options.enabled = typeof options.enabled !== "undefined" ? options.enabled : true;
  return {
    name: "unhead:remove-server-composables",
    enforce: "post",
    transformInclude(id) {
      if (!options.enabled)
        return false;
      const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href));
      const { type } = parseQuery(search);
      if (pathname.match(/[\\/]node_modules[\\/]/))
        return false;
      if (options.filter?.include?.some((pattern) => id.match(pattern)))
        return true;
      if (options.filter?.exclude?.some((pattern) => id.match(pattern)))
        return false;
      if (pathname.endsWith(".vue") && (type === "script" || !search))
        return true;
      if (pathname.match(/\.((c|m)?j|t)sx?$/g))
        return true;
      return false;
    },
    async transform(code, id) {
      if (!code.includes("useServerHead") && !code.includes("useServerHeadSafe") && !code.includes("useServerSeoMeta") && !code.includes("useSchemaOrg")) {
        return;
      }
      let transformed;
      try {
        transformed = await transform(code, id, {
          parserOptions: {},
          transformer: [
            RemoveFunctions([
              "useServerHead",
              "useServerHeadSafe",
              "useServerSeoMeta",
              // plugins
              "useSchemaOrg"
            ])
          ]
        });
      } catch (e) {
      }
      return transformed;
    },
    webpack(ctx) {
      if (ctx.name === "server")
        options.enabled = false;
    },
    vite: {
      apply(config, env) {
        if (env.ssrBuild || env.isSsrBuild) {
          options.enabled = false;
          return true;
        }
        return false;
      }
    }
  };
});

/**
 * @typedef { import('estree').Node} Node
 * @typedef {{
 *   skip: () => void;
 *   remove: () => void;
 *   replace: (node: Node) => void;
 * }} WalkerContext
 */

class WalkerBase {
	constructor() {
		/** @type {boolean} */
		this.should_skip = false;

		/** @type {boolean} */
		this.should_remove = false;

		/** @type {Node | null} */
		this.replacement = null;

		/** @type {WalkerContext} */
		this.context = {
			skip: () => (this.should_skip = true),
			remove: () => (this.should_remove = true),
			replace: (node) => (this.replacement = node)
		};
	}

	/**
	 * @template {Node} Parent
	 * @param {Parent | null | undefined} parent
	 * @param {keyof Parent | null | undefined} prop
	 * @param {number | null | undefined} index
	 * @param {Node} node
	 */
	replace(parent, prop, index, node) {
		if (parent && prop) {
			if (index != null) {
				/** @type {Array<Node>} */ (parent[prop])[index] = node;
			} else {
				/** @type {Node} */ (parent[prop]) = node;
			}
		}
	}

	/**
	 * @template {Node} Parent
	 * @param {Parent | null | undefined} parent
	 * @param {keyof Parent | null | undefined} prop
	 * @param {number | null | undefined} index
	 */
	remove(parent, prop, index) {
		if (parent && prop) {
			if (index !== null && index !== undefined) {
				/** @type {Array<Node>} */ (parent[prop]).splice(index, 1);
			} else {
				delete parent[prop];
			}
		}
	}
}

/**
 * @typedef { import('estree').Node} Node
 * @typedef { import('./walker.js').WalkerContext} WalkerContext
 * @typedef {(
 *    this: WalkerContext,
 *    node: Node,
 *    parent: Node | null,
 *    key: string | number | symbol | null | undefined,
 *    index: number | null | undefined
 * ) => void} SyncHandler
 */

class SyncWalker extends WalkerBase {
	/**
	 *
	 * @param {SyncHandler} [enter]
	 * @param {SyncHandler} [leave]
	 */
	constructor(enter, leave) {
		super();

		/** @type {boolean} */
		this.should_skip = false;

		/** @type {boolean} */
		this.should_remove = false;

		/** @type {Node | null} */
		this.replacement = null;

		/** @type {WalkerContext} */
		this.context = {
			skip: () => (this.should_skip = true),
			remove: () => (this.should_remove = true),
			replace: (node) => (this.replacement = node)
		};

		/** @type {SyncHandler | undefined} */
		this.enter = enter;

		/** @type {SyncHandler | undefined} */
		this.leave = leave;
	}

	/**
	 * @template {Node} Parent
	 * @param {Node} node
	 * @param {Parent | null} parent
	 * @param {keyof Parent} [prop]
	 * @param {number | null} [index]
	 * @returns {Node | null}
	 */
	visit(node, parent, prop, index) {
		if (node) {
			if (this.enter) {
				const _should_skip = this.should_skip;
				const _should_remove = this.should_remove;
				const _replacement = this.replacement;
				this.should_skip = false;
				this.should_remove = false;
				this.replacement = null;

				this.enter.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const skipped = this.should_skip;
				const removed = this.should_remove;

				this.should_skip = _should_skip;
				this.should_remove = _should_remove;
				this.replacement = _replacement;

				if (skipped) return node;
				if (removed) return null;
			}

			/** @type {keyof Node} */
			let key;

			for (key in node) {
				/** @type {unknown} */
				const value = node[key];

				if (value && typeof value === 'object') {
					if (Array.isArray(value)) {
						const nodes = /** @type {Array<unknown>} */ (value);
						for (let i = 0; i < nodes.length; i += 1) {
							const item = nodes[i];
							if (isNode(item)) {
								if (!this.visit(item, node, key, i)) {
									// removed
									i--;
								}
							}
						}
					} else if (isNode(value)) {
						this.visit(value, node, key, null);
					}
				}
			}

			if (this.leave) {
				const _replacement = this.replacement;
				const _should_remove = this.should_remove;
				this.replacement = null;
				this.should_remove = false;

				this.leave.call(this.context, node, parent, prop, index);

				if (this.replacement) {
					node = this.replacement;
					this.replace(parent, prop, index, node);
				}

				if (this.should_remove) {
					this.remove(parent, prop, index);
				}

				const removed = this.should_remove;

				this.replacement = _replacement;
				this.should_remove = _should_remove;

				if (removed) return null;
			}
		}

		return node;
	}
}

/**
 * Ducktype a node.
 *
 * @param {unknown} value
 * @returns {value is Node}
 */
function isNode(value) {
	return (
		value !== null && typeof value === 'object' && 'type' in value && typeof value.type === 'string'
	);
}

/**
 * @typedef {import('estree').Node} Node
 * @typedef {import('./sync.js').SyncHandler} SyncHandler
 * @typedef {import('./async.js').AsyncHandler} AsyncHandler
 */

/**
 * @param {Node} ast
 * @param {{
 *   enter?: SyncHandler
 *   leave?: SyncHandler
 * }} walker
 * @returns {Node | null}
 */
function walk(ast, { enter, leave }) {
	const instance = new SyncWalker(enter, leave);
	return instance.visit(ast, null);
}

const UseSeoMetaTransform = createUnplugin((options = {}) => {
  options.imports = options.imports || true;
  return {
    name: "unhead:use-seo-meta-transform",
    enforce: "post",
    transformInclude(id) {
      const { pathname, search } = parseURL(decodeURIComponent(pathToFileURL(id).href));
      const { type } = parseQuery(search);
      if (pathname.match(/[\\/]node_modules[\\/]/))
        return false;
      if (options.filter?.include?.some((pattern) => id.match(pattern)))
        return true;
      if (options.filter?.exclude?.some((pattern) => id.match(pattern)))
        return false;
      if (pathname.endsWith(".vue") && (type === "script" || !search))
        return true;
      if (pathname.match(/\.((c|m)?j|t)sx?$/g))
        return true;
      return false;
    },
    async transform(code, id) {
      if (!code.includes("useSeoMeta") && !code.includes("useServerSeoMeta"))
        return;
      const packages = ["unhead", "@unhead/vue", "unhead"];
      const statements = findStaticImports(code).filter((i) => packages.includes(i.specifier));
      const importNames = {};
      for (const i of statements.flatMap((i2) => parseStaticImport(i2))) {
        if (i.namedImports) {
          for (const key in i.namedImports)
            importNames[i.namedImports[key]] = key;
        }
      }
      const ast = this.parse(code);
      const s = new MagicString(code);
      const extraImports = /* @__PURE__ */ new Set();
      walk(ast, {
        enter(_node) {
          if (options.imports && _node.type === "ImportDeclaration" && packages.includes(_node.source.value)) {
            const node = _node;
            if (
              // @ts-expect-error untyped
              !node.specifiers.some((s2) => s2.type === "ImportSpecifier" && ["useSeoMeta", "useServerSeoMeta"].includes(s2.imported?.name))
            )
              return;
            const imports = Object.values(importNames);
            if (!imports.includes("useHead"))
              extraImports.add(`import { useHead } from '${node.source.value}'`);
            if (!imports.includes("useServerHead") && imports.includes("useServerSeoMeta"))
              extraImports.add(`import { useServerHead } from '${node.source.value}'`);
          } else if (_node.type === "CallExpression" && _node.callee.type === "Identifier" && Object.keys({
            useSeoMeta: "useSeoMeta",
            useServerSeoMeta: "useServerSeoMeta",
            ...importNames
          }).includes(_node.callee.name)) {
            const node = _node;
            const calleeName = importNames[node.callee.name] || node.callee.name;
            const properties = node.arguments[0].properties;
            if (!properties)
              return;
            let output = [];
            const title = properties.find((property) => property.key?.name === "title");
            const titleTemplate = properties.find((property) => property.key?.name === "titleTemplate");
            const meta = properties.filter((property) => property.key?.name !== "title" && property.key?.name !== "titleTemplate");
            if (title || titleTemplate || calleeName === "useSeoMeta") {
              output.push("useHead({");
              if (title) {
                output.push(`  title: ${code.substring(title.value.start, title.value.end)},`);
              }
              if (titleTemplate) {
                output.push(`  titleTemplate: ${code.substring(titleTemplate.value.start, titleTemplate.value.end)},`);
              }
            }
            if (calleeName === "useServerSeoMeta") {
              if (output.length)
                output.push("});");
              output.push("useServerHead({");
            }
            if (meta.length)
              output.push("  meta: [");
            meta.forEach((property) => {
              if (property.type === "SpreadElement") {
                output = false;
                return;
              }
              if (property.key.type !== "Identifier" || !property.value) {
                output = false;
                return;
              }
              if (output === false)
                return;
              const propertyKey = property.key;
              const key = resolveMetaKeyType(propertyKey.name);
              const keyValue = resolveMetaKeyValue(propertyKey.name);
              const valueKey = key === "charset" ? "charset" : "content";
              let value = code.substring(property.value.start, property.value.end);
              if (property.value.type === "ArrayExpression") {
                output = false;
                return;
              } else if (property.value.type === "ObjectExpression") {
                const isStatic = property.value.properties.every((p) => p.value.type === "Literal" && typeof p.value.value === "string");
                if (!isStatic) {
                  output = false;
                  return;
                }
                const context = createContext({
                  resolvePackedMetaObjectValue
                });
                const start = property.value.start;
                const end = property.value.end;
                try {
                  value = JSON.stringify(runInContext(`resolvePackedMetaObjectValue(${code.slice(start, end)})`, context));
                } catch {
                  output = false;
                  return;
                }
              }
              if (valueKey === "charset")
                output.push(`    { ${key}: ${value} },`);
              else
                output.push(`    { ${key}: '${keyValue}', ${valueKey}: ${value} },`);
            });
            if (output) {
              if (meta.length)
                output.push("  ]");
              output.push("})");
              s.overwrite(node.start, node.end, output.join("\n"));
            }
          }
        }
      });
      if (s.hasChanged()) {
        const prependImports = [...extraImports];
        if (prependImports.length)
          s.prepend(`${prependImports.join("\n")}
`);
        return {
          code: s.toString(),
          map: s.generateMap({ includeContent: true, source: id })
        };
      }
    }
  };
});

export { TreeshakeServerComposables as T, UseSeoMetaTransform as U };

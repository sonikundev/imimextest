import { useNuxt, createResolver, addTemplate, defineNuxtModule, useLogger, addServerHandler, addVitePlugin, addPlugin } from '@nuxt/kit';
import UnheadVite from '@unhead/addons/vite';
import { installNuxtSiteConfig } from 'nuxt-site-config-kit';
import fg from 'fast-glob';
import { resolve, dirname, basename, relative, extname } from 'pathe';
import { defu } from 'defu';
import { unpackMeta } from '@unhead/shared';
import { joinURL, encodePath } from 'ufo';
import { readFile } from 'node:fs/promises';
import fs from 'node:fs';
import imageSize from 'image-size';
import escapeRE from 'escape-string-regexp';

function hasLinkRel(input, rel) {
  return input.link?.some((link) => link.rel === rel);
}
function hasMetaProperty(input, property) {
  return input.meta?.some((meta) => meta.property === property);
}
async function getImageMeta(base, path, isIcon = false) {
  const absolutePath = resolve(base, path);
  const file = absolutePath.split("/").pop();
  const keyword = file.split(".")[0];
  let ext = absolutePath.split(".").pop();
  if (ext === "jpg")
    ext = "jpeg";
  const { width, height } = await getImageDimensions(absolutePath);
  const payload = {
    type: ext === "svg" ? `image/svg+xml` : `image/${ext}`
  };
  if (!isIcon) {
    payload.width = width;
    payload.height = height;
    const altTextPath = resolve(dirname(absolutePath), `${keyword}.alt.txt`);
    if (fs.existsSync(altTextPath)) {
      payload.alt = fs.readFileSync(altTextPath, "utf8");
      payload.alt = payload.alt.replace(/\n/g, " ").trim();
    }
  } else {
    if (path.includes(".dark") || path.includes("-dark"))
      payload.media = "(prefers-color-scheme: dark)";
    else if (path.includes(".light") || path.includes("-light"))
      payload.media = "(prefers-color-scheme: light)";
    if (ext !== "svg") {
      payload.sizes = `${width}x${height}`;
    }
  }
  return payload;
}
async function getImageDimensions(absolutePath) {
  const buffer = await readFile(absolutePath);
  return imageSize(buffer);
}

const MetaTagFileGlobs = [
  "**/*og-image.{png,jpg,jpeg,gif}",
  "**/*opengraph-image.{png,jpg,jpeg,gif}",
  "**/*twitter-image.{png,jpg,jpeg,gif}",
  "**/*icon.{ico,jpg,jpeg,png,svg}",
  "**/*icon-*.{ico,jpg,jpeg,png,svg}",
  "**/*apple-icon.{jpg,jpeg,png}",
  "**/*apple-touch.{jpg,jpeg,png}",
  "**/*apple-touch-icon.{jpg,jpeg,png}"
];

async function generateTagsFromPublicFiles(nuxt = useNuxt()) {
  const publicDirPath = resolve(nuxt.options.rootDir, nuxt.options.dir.public);
  const rootPublicFiles = (await fg(MetaTagFileGlobs, { cwd: publicDirPath, onlyFiles: true, deep: 1 })).map((file) => basename(file));
  const headConfig = defu(nuxt.options.app.head, {
    link: [],
    meta: []
  });
  if (!hasLinkRel(headConfig, "icon")) {
    if (rootPublicFiles.includes("favicon.ico") && nuxt.options.app.baseURL !== "/") {
      headConfig.link.push({
        rel: "icon",
        href: joinURL(nuxt.options.app.baseURL, "favicon.ico"),
        sizes: "any"
      });
    }
    const isIcon = (file) => file.includes("icon") && !file.endsWith(".ico");
    const isAppleTouchIcon = (file) => file.startsWith("apple-icon.") || file.startsWith("apple-touch-icon.") || file.startsWith("apple-touch.");
    headConfig.link.push(
      ...await Promise.all([
        ...rootPublicFiles.filter((file) => isIcon(file) && !isAppleTouchIcon(file)).sort().map(async (iconFile) => {
          const meta = await getImageMeta(publicDirPath, iconFile, true);
          delete meta.sizes;
          return {
            rel: "icon",
            href: joinURL(nuxt.options.app.baseURL, iconFile),
            ...meta
          };
        }),
        ...rootPublicFiles.filter((file) => isAppleTouchIcon(file)).sort().map(async (appleIconFile) => {
          const meta = await getImageMeta(publicDirPath, appleIconFile, true);
          return {
            rel: "apple-touch-icon",
            href: joinURL(nuxt.options.app.baseURL, appleIconFile),
            ...meta
          };
        })
      ])
    );
  }
  let hasTwitterImage = hasMetaProperty(headConfig, "twitter:image");
  if (!hasTwitterImage) {
    const twitterImageFiles = rootPublicFiles.filter((file) => file.startsWith("twitter-image.")).sort();
    if (twitterImageFiles.length) {
      headConfig.meta.push(
        ...(await Promise.all(twitterImageFiles.map(async (twitterImageFile) => {
          const dimensions = await getImageDimensions(resolve(publicDirPath, twitterImageFile));
          return unpackMeta({
            twitterImage: {
              url: twitterImageFile,
              width: dimensions.width,
              height: dimensions.height
            }
          });
        }))).flat()
      );
      hasTwitterImage = true;
    }
  }
  if (!hasMetaProperty(headConfig, "og:image")) {
    const ogImageFiles = rootPublicFiles.filter((file) => file.startsWith("og-image.") || file.startsWith("og.")).sort();
    if (ogImageFiles.length) {
      headConfig.meta.push(
        ...(await Promise.all(ogImageFiles.map(async (src) => {
          const meta = await getImageMeta(publicDirPath, src, false);
          delete meta.sizes;
          const seoMeta = {
            ogImage: {
              url: src,
              ...meta
            }
          };
          if (!hasTwitterImage) {
            seoMeta.twitterImage = {
              url: src,
              ...meta
            };
          }
          return unpackMeta(seoMeta);
        }))).flat()
      );
    }
  }
  nuxt.options.app.head = headConfig;
}

function setupNuxtConfigAppHeadWithMoreDefaults(nuxt = useNuxt()) {
  const headConfig = nuxt.options.app.head;
  headConfig.link = headConfig.link || [];
  headConfig.htmlAttrs = headConfig.htmlAttrs || {};
  headConfig.link = headConfig.link || [];
  headConfig.meta = headConfig.meta || [];
  if (!hasMetaProperty(headConfig, "og:type")) {
    headConfig.meta.push({
      property: "og:type",
      content: "website"
    });
  }
  nuxt.options.app.head = headConfig;
}

function extendNuxtConfigAppHeadSeoMeta(nuxt = useNuxt()) {
  const seoMeta = nuxt.options.app?.seoMeta || false;
  if (!seoMeta)
    return;
  nuxt.options.app.head = nuxt.options.app.head || {};
  nuxt.options.app.head = {
    ...nuxt.options.app.head,
    meta: [
      ...nuxt.options.app.head.meta || [],
      ...unpackMeta(seoMeta)
    ]
  };
  return nuxt.options.app.head;
}

function extendTypes(module, template) {
  const nuxt = useNuxt();
  const { resolve } = createResolver(import.meta.url);
  addTemplate({
    filename: `module/${module}.d.ts`,
    getContents: async () => {
      const typesPath = relative(resolve(nuxt.options.rootDir, nuxt.options.buildDir, "module"), resolve("runtime/types"));
      const s = await template({ typesPath });
      return `// Generated by ${module}
${s}
export {}
`;
    }
  });
  nuxt.hooks.hook("prepare:types", ({ references }) => {
    references.push({ path: resolve(nuxt.options.buildDir, `module/${module}.d.ts`) });
  });
}

function extendNuxtConfigAppHeadTypes(nuxt = useNuxt()) {
  extendTypes("nuxt-seo-experiments.assets", async () => {
    const paths = (await fg(["**/*"], { cwd: resolve(nuxt.options.srcDir, "public") })).map((p) => `/${p}`);
    const jsPaths = paths.filter((p) => p.endsWith(".js") || p.endsWith(".mjs"));
    return `
declare module '#app' {
  import { HeadEntry, HeadTag } from '@unhead/schema'

  interface RuntimeNuxtHooks {
    'head:tags': (tag: HeadTag[]) => Promise<void> | void
    'head:entries': (entries: HeadEntry[]) => Promise<void> | void
  }
}
declare module '@unhead/schema' {

  type PublicFiles = ${[...paths.map((p) => `'${p}'`), "(string & Record<never, never>)"].join(" | ")}
  type JsFiles = ${[...jsPaths.map((p) => `'${p}'`), "(string & Record<never, never>)"].join(" | ")}

  interface SchemaAugmentations {
    link: import('@unhead/schema').UserTagConfigWithoutInnerContent & {
      href: PublicFiles
    }
    script: import('@unhead/schema').TagUserProperties & {
      src: JsFiles
    }
  }
}`;
  });
}

function generateNuxtPageFromFile(file, pagesDir) {
  const segments = relative(pagesDir, file).replace(new RegExp(`${escapeRE(extname(file))}$`), "").split("/");
  const route = {
    name: "",
    path: "",
    file,
    children: []
  };
  let parent = [];
  for (let i = 0; i < segments.length; i++) {
    const segment = segments[i];
    const tokens = parseSegment(segment);
    const segmentName = tokens.map(({ value }) => value).join("");
    route.name += (route.name && "-") + segmentName;
    const child = parent.find((parentRoute) => parentRoute.name === route.name && !parentRoute.path.endsWith("(.*)*"));
    if (child && child.children) {
      parent = child.children;
      route.path = "";
    } else if (segmentName === "index" && !route.path) {
      route.path += "/";
    } else if (segmentName !== "index") {
      route.path += getRoutePath(tokens);
    }
  }
  if (route.name)
    route.name = route.name.replace(/-index$/, "");
  return route;
}
function getRoutePath(tokens) {
  return tokens.reduce((path, token) => {
    return path + (token.type === 2 /* optional */ ? `:${token.value}?` : token.type === 1 /* dynamic */ ? `:${token.value}` : token.type === 3 /* catchall */ ? `:${token.value}(.*)*` : encodePath(token.value));
  }, "/");
}
const PARAM_CHAR_RE = /[\w.]/;
function parseSegment(segment) {
  let state = 0 /* initial */;
  let i = 0;
  let buffer = "";
  const tokens = [];
  function consumeBuffer() {
    if (!buffer)
      return;
    if (state === 0 /* initial */)
      throw new Error("wrong state");
    tokens.push({
      type: state === 1 /* static */ ? 0 /* static */ : state === 2 /* dynamic */ ? 1 /* dynamic */ : state === 3 /* optional */ ? 2 /* optional */ : 3 /* catchall */,
      value: buffer
    });
    buffer = "";
  }
  while (i < segment.length) {
    const c = segment[i];
    switch (state) {
      case 0 /* initial */:
        buffer = "";
        if (c === "[") {
          state = 2 /* dynamic */;
        } else {
          i--;
          state = 1 /* static */;
        }
        break;
      case 1 /* static */:
        if (c === "[") {
          consumeBuffer();
          state = 2 /* dynamic */;
        } else {
          buffer += c;
        }
        break;
      case 4 /* catchall */:
      case 2 /* dynamic */:
      case 3 /* optional */:
        if (buffer === "...") {
          buffer = "";
          state = 4 /* catchall */;
        }
        if (c === "[" && state === 2 /* dynamic */)
          state = 3 /* optional */;
        if (c === "]" && (state !== 3 /* optional */ || buffer[buffer.length - 1] === "]")) {
          if (!buffer)
            throw new Error("Empty param");
          else
            consumeBuffer();
          state = 0 /* initial */;
        } else if (PARAM_CHAR_RE.test(c)) {
          buffer += c;
        } else ;
        break;
    }
    i++;
  }
  if (state === 2 /* dynamic */)
    throw new Error(`Unfinished param "${buffer}"`);
  consumeBuffer();
  return tokens;
}

async function generateTagsFromPageDirImages(nuxt = useNuxt()) {
  const pagesDir = resolve(nuxt.options.rootDir, nuxt.options.dir.pages);
  const files = await fg(MetaTagFileGlobs, { cwd: pagesDir, onlyFiles: true });
  const appendRouteRules = {};
  const devMiddlewareMap = {};
  const nitroOutputMap = [];
  for (const file of files) {
    const fileName = basename(file);
    const keyword = fileName.split(".")[0];
    let { path } = generateNuxtPageFromFile(resolve(pagesDir, dirname(file)), pagesDir);
    const meta = await getImageMeta(pagesDir, file);
    if (path.endsWith("/_dir"))
      path = path.replace(/\/_dir$/, "");
    const src = joinURL(path, fileName);
    if (["icon", "apple-touch-icon", "apple-icon"].includes(keyword) || keyword.startsWith("icon-")) {
      appendRouteRules[`${path}/**`] = {
        head: {
          link: [
            { rel: keyword, type: meta.type, href: src, sizes: meta.sizes }
          ]
        }
      };
    } else {
      appendRouteRules[`${path}/**`] = {
        seoMeta: {
          [["opengraph-image", "og-image"].includes(keyword) ? "ogImage" : "twitterImage"]: [{ url: src, ...meta, sizes: void 0 }]
        }
      };
    }
    devMiddlewareMap[src] = resolve(pagesDir, file);
    nitroOutputMap.push({
      src: resolve(pagesDir, file),
      dest: src.slice(1)
      // remove leading slash
    });
  }
  nuxt.options.routeRules = defu(appendRouteRules, nuxt.options.routeRules);
  nuxt.options.nitro.routeRules = defu(appendRouteRules, nuxt.options.nitro.routeRules);
  if (nuxt.options.dev) {
    nuxt.hooks.hook("nitro:config", async (nitroConfig) => {
      nitroConfig.virtual["#nuxt-seo-experiments/pageDirImages"] = `export const fileMapping = ${JSON.stringify(devMiddlewareMap)}`;
    });
  }
  nuxt.hooks.hook("nitro:build:public-assets", (_nitro) => {
    const publicDir = resolve(_nitro.options.output.dir, _nitro.options.output.publicDir);
    nitroOutputMap.forEach(({ src, dest }) => {
      const resolvedDest = resolve(publicDir, dest);
      const destFolder = dirname(resolvedDest);
      if (!fs.existsSync(destFolder))
        fs.mkdirSync(destFolder, { recursive: true });
      if (!fs.existsSync(resolvedDest))
        fs.copyFileSync(src, resolvedDest);
    });
  });
}

const module = defineNuxtModule({
  meta: {
    name: "nuxt-seo-experiments",
    configKey: "seoExperiments",
    compatibility: {
      nuxt: ">=3.6.1",
      bridge: false
    }
  },
  defaults: {
    enabled: true,
    debug: false,
    metaDataFiles: true,
    mergeWithSiteConfig: true,
    extendRouteRules: true,
    fixRequiredAbsoluteMetaTagsLinks: true,
    extendNuxtConfigAppHeadSeoMeta: true,
    treeShakeUseSeoMeta: true,
    extendNuxtConfigAppHeadTypes: true,
    setupNuxtConfigAppHeadWithMoreDefaults: true,
    automaticOgAndTwitterTags: true
  },
  async setup(config, nuxt) {
    const logger = useLogger("nuxt-seo-experiments");
    logger.level = config.debug || nuxt.options.debug ? 4 : 3;
    if (config.enabled === false) {
      logger.debug("The module is disabled, skipping setup.");
      return;
    }
    const { resolve } = createResolver(import.meta.url);
    await installNuxtSiteConfig();
    if (config.metaDataFiles) {
      await generateTagsFromPublicFiles();
      await generateTagsFromPageDirImages();
      if (nuxt.options.dev) {
        addServerHandler({
          handler: resolve("runtime/nitro/middleware/resolveImagesInPagesDir")
        });
      }
    }
    if (config.extendNuxtConfigAppHeadSeoMeta)
      extendNuxtConfigAppHeadSeoMeta();
    if (config.setupNuxtConfigAppHeadWithMoreDefaults)
      setupNuxtConfigAppHeadWithMoreDefaults(nuxt);
    if (config.extendNuxtConfigAppHeadTypes)
      extendNuxtConfigAppHeadTypes();
    extendTypes("nuxt-seo-experiments", async () => {
      return `
declare module 'nitropack' {
  interface NitroRouteRules {
     seoMeta?: import('@unhead/schema').UseSeoMetaInput
     head?: import('@unhead/schema').Head
  }
  interface NitroRouteConfig {
    seoMeta?: import('@unhead/schema').UseSeoMetaInput
    head?: import('@unhead/schema').Head
  }
}

declare module '@nuxt/schema' {
  interface NuxtAppConfig { seoMeta?: import('@unhead/schema').UseSeoMetaInput }
  interface NuxtConfig { app?: ConfigSchema['app'] & { seoMeta?: import('@unhead/schema').UseSeoMetaInput } }
  interface NuxtOptions { app: ConfigSchema['app'] & { seoMeta?: import('@unhead/schema').UseSeoMetaInput } }
}

declare module 'nuxt/schema' {
  interface NuxtAppConfig { seoMeta?: import('@unhead/schema').UseSeoMetaInput }
  interface NuxtConfig { app?: import('@nuxt/schema').ConfigSchema['app'] & { seoMeta?: import('@unhead/schema').UseSeoMetaInput } }
  interface NuxtOptions { app: import('@nuxt/schema').ConfigSchema['app'] & { seoMeta?: import('@unhead/schema').UseSeoMetaInput } }
}
`;
    });
    const runtimeDir = resolve("./runtime/nuxt");
    if (config.treeShakeUseSeoMeta)
      addVitePlugin(UnheadVite());
    if (config.automaticOgAndTwitterTags)
      addPlugin({ src: resolve(runtimeDir, "plugins", "inferSeoMetaPlugin") });
    if (config.mergeWithSiteConfig)
      addPlugin({ src: resolve(runtimeDir, "plugins", "siteConfig") });
    if (config.extendRouteRules)
      addPlugin({ src: resolve(runtimeDir, "plugins", "0.routeRules.server"), mode: "server" });
    if (config.fixRequiredAbsoluteMetaTagsLinks)
      addPlugin({ src: resolve(runtimeDir, "plugins", "1.absoluteImageUrls.server"), mode: "server" });
  }
});

export { module as default };

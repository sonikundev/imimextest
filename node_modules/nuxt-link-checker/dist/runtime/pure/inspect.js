import { parseURL } from "ufo";
import RuleTrailingSlash from "./inspections/trailing-slash.js";
import RuleMissingHash from "./inspections/missing-hash.js";
import RuleNoBaseLess from "./inspections/no-baseless.js";
import RuleNoJavascript from "./inspections/no-javascript.js";
import RuleAbsoluteSiteUrls from "./inspections/absolute-site-urls.js";
import RuleRedirects from "./redirects.js";
import RuleNoErrorResponse from "./inspections/no-error-response-status.js";
import RuleDescriptiveLinkText from "./inspections/descriptive-link-text.js";
import { isNonFetchableLink } from "./inspections/util.js";
export const DefaultInspections = {
  "missing-hash": RuleMissingHash(),
  "no-error-response": RuleNoErrorResponse(),
  "no-baseless": RuleNoBaseLess(),
  "no-javascript": RuleNoJavascript(),
  "trailing-slash": RuleTrailingSlash(),
  "absolute-site-urls": RuleAbsoluteSiteUrls(),
  "redirects": RuleRedirects(),
  "link-text": RuleDescriptiveLinkText()
};
export function inspect(ctx, rules = DefaultInspections) {
  const res = { error: [], warning: [], fix: ctx.link, link: ctx.link };
  let link = ctx.link;
  const url = parseURL(link);
  if (!url.pathname && !url.protocol && !url.host && !isNonFetchableLink(link)) {
    res.error.push({
      name: "invalid-url",
      scope: "error",
      message: `Invalid URL: ${link}`
    });
    return res;
  }
  const validInspections = Object.entries(rules).filter(([name]) => !ctx.skipInspections || !ctx.skipInspections.includes(name)).map(([, rule]) => rule);
  for (const rule of validInspections) {
    rule.test({
      ...ctx,
      link,
      url,
      report(obj) {
        res[obj.scope].push(obj);
        if (obj.fix)
          link = obj.fix;
      }
    });
  }
  res.passes = !res.error?.length && !res.warning?.length;
  res.fix = link;
  res.textContent = ctx.textContent;
  return res;
}

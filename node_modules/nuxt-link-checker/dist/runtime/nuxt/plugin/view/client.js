import { computed, createApp, h, ref, shallowReactive, unref } from "vue";
import { useLocalStorage } from "@vueuse/core";
import { createFilter } from "../../../pure/sharedUtils.js";
import Main from "./Main.vue";
import { linkDb } from "./state.js";
import { useRoute, useRuntimeConfig } from "#imports";
function resolveDevtoolsIframe() {
  return document.querySelector("#nuxt-devtools-iframe")?.contentWindow?.__NUXT_DEVTOOLS__;
}
function resolvePathsForEl(el) {
  const parents = [];
  let parent = el.parentElement;
  while (parent) {
    parents.push(parent);
    if (parents.length > 5)
      break;
    parent = parent.parentElement;
  }
  return [
    ...new Set(parents.map((p) => p.getAttribute("data-v-inspector")?.split(":")?.[0] || false))
  ].filter(Boolean);
}
export async function setupLinkCheckerClient({ nuxt }) {
  let queue = [];
  let queueWorkerTimer;
  const inspectionEls = ref([]);
  const highlightedLink = ref(null);
  const visibleLinks = /* @__PURE__ */ new Set();
  let lastIds = [];
  let elMap = {};
  let devtoolsClient;
  let isOpeningDevtools = false;
  const route = useRoute();
  let startQueueIdleId;
  let startQueueTimeoutId;
  const showInspections = useLocalStorage("nuxt-link-checker:show-inspections", true);
  const runtimeConfig = useRuntimeConfig().public["nuxt-link-checker"];
  const filter = createFilter({
    exclude: runtimeConfig.excludeLinks
  });
  const client = shallowReactive({
    isWorkingQueue: false,
    isStarted: false,
    scanLinks() {
      elMap = {};
      visibleLinks.clear();
      lastIds = [...new Set([...document.querySelectorAll("#__nuxt [id]")].map((el) => el.id))];
      [...document.querySelectorAll("#__nuxt a[href]")].map((el) => ({ el, link: el.getAttribute("href") })).forEach(({ el, link }) => {
        if (!link)
          return;
        if (!filter(link))
          return;
        visibleLinks.add(link);
        elMap[link] = elMap[link] || [];
        if (elMap[link].includes(el))
          return;
        elMap[link].push(el);
        const paths = resolvePathsForEl(el);
        const payload = linkDb.value[route.path]?.find((d) => d.link === link);
        if (payload || queue.find((q) => q.link === link)) {
          client.maybeAttachEls(payload);
          return;
        }
        queue.push({
          link,
          textContent: (el.textContent || el.getAttribute("aria-label") || el.getAttribute("title") || "").trim(),
          paths
        });
      });
      client.broadcast("updated");
    },
    startQueueWorker() {
      client.stopQueueWorker();
      async function workQueue() {
        if (queue.length <= 0) {
          client.stopQueueWorker();
          return;
        }
        const tasks = [];
        while (tasks.length < 50 && queue.length > 0)
          tasks.push(queue.pop());
        if (!tasks.length) {
          client.stopQueueWorker();
          return;
        }
        client.isWorkingQueue = true;
        linkDb.value[route.path] = linkDb.value[route.path] || [];
        const payloads = await $fetch("/__link-checker__/inspect", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: {
            tasks,
            ids: lastIds
          }
        });
        payloads.forEach((payload) => {
          if (!payload)
            return;
          linkDb.value[route.path].push(payload);
          client.maybeAttachEls(payload);
        });
        client.broadcast("queueWorking", { queueLength: queue.length });
        queueWorkerTimer = setTimeout(workQueue, 200);
      }
      workQueue();
    },
    maybeAttachEls(payload) {
      if (!payload || payload.passes)
        return;
      const els = elMap?.[payload.link] || [];
      for (const el of els)
        client.inspectionEls.value.push({ ...unref(payload), el });
    },
    stopQueueWorker() {
      if (client.isWorkingQueue) {
        queue = [];
        client.isWorkingQueue = false;
        if (queueWorkerTimer)
          clearInterval(queueWorkerTimer);
      }
    },
    broadcast(event, payload) {
      if (!import.meta.hot) {
        console.warn("No hot context");
        return;
      }
      try {
        import.meta.hot.send(`nuxt-link-checker:${event}`, payload);
      } catch {
      }
    },
    openDevtoolsToLink(link) {
      if (isOpeningDevtools)
        return;
      devtoolsClient = resolveDevtoolsIframe();
      isOpeningDevtools = true;
      if (!devtoolsClient) {
        const devtoolsButton = document.querySelector(".nuxt-devtools-nuxt-button");
        if (devtoolsButton) {
          devtoolsButton.dispatchEvent(new MouseEvent("click", { bubbles: true }));
          const interval = setInterval(() => {
            devtoolsClient = resolveDevtoolsIframe();
            if (devtoolsClient && devtoolsClient.host?.getIframe()) {
              devtoolsClient.host.getIframe().src = `/__nuxt_devtools__/client/modules/custom-nuxt-link-checker?link=${encodeURIComponent(link)}`;
              isOpeningDevtools = false;
              clearInterval(interval);
            }
          }, 250);
        }
      } else {
        if (typeof devtoolsClient.host.open === "function")
          devtoolsClient.host.open();
        else
          devtoolsClient.host.devtools.open();
        const srcPath = new URL(devtoolsClient.host.getIframe().src).pathname;
        if (!srcPath.startsWith("/__nuxt_devtools__/client/modules/custom-nuxt-link-checker")) {
          devtoolsClient.host.getIframe().src = `/__nuxt_devtools__/client/modules/custom-nuxt-link-checker?link=${encodeURIComponent(link)}`;
        } else {
          client.broadcast("filter", { link });
        }
        isOpeningDevtools = false;
      }
    },
    reset(hard) {
      if (hard)
        linkDb.value = {};
      client.inspectionEls.value = [];
      client.restart();
    },
    restart() {
      if (startQueueIdleId)
        cancelIdleCallback(startQueueIdleId);
      startQueueIdleId = requestIdleCallback(() => {
        client.stopQueueWorker();
        if (!startQueueTimeoutId) {
          startQueueTimeoutId = setTimeout(() => {
            client.scanLinks();
            client.startQueueWorker();
            startQueueTimeoutId = false;
          }, 250);
        }
      });
    },
    start() {
      if (client.isStarted)
        return;
      client.isStarted = true;
      if (import.meta.hot) {
        import.meta.hot.on("nuxt-link-checker:reset", () => {
          client.reset(true);
        });
        import.meta.hot.on("nuxt-link-checker:scroll-to-link", (link) => {
          const inspection = inspectionEls.value.find((i) => i.link === link);
          if (inspection) {
            inspection.el.scrollIntoView({
              behavior: "smooth"
            });
            highlightedLink.value = inspection.link;
            setTimeout(() => {
              highlightedLink.value = null;
            }, 5e3);
          }
        });
        import.meta.hot.on("nuxt-link-checker:live-inspections", ({ enabled }) => {
          showInspections.value = enabled;
        });
        import.meta.hot.on("vite:afterUpdate", (ctx) => {
          if (ctx.updates.some((c) => c.type === "js-update"))
            client.reset(true);
        });
      }
      const observer = new MutationObserver(() => {
        client.reset(false);
      });
      observer.observe(document.querySelector("#__nuxt"), {
        childList: true,
        subtree: true,
        // we only care if links are added, removed or updated
        attributeFilter: ["href"]
      });
      const holder = document.createElement("div");
      holder.id = "nuxt-link-checker-container";
      holder.setAttribute("data-v-inspector-ignore", "true");
      document.body.appendChild(holder);
      const app = createApp({
        render: () => h(Main, { client, inspections: client.inspectionEls, highlightedLink })
      });
      app.mount(holder);
      client.restart();
    },
    visibleLinks,
    inspectionEls,
    linkDb: computed(() => linkDb.value[route.path] || []),
    showInspections
  });
  if (nuxt.vueApp._instance)
    nuxt.vueApp._instance.appContext.provides.linkChecker = client;
  if (import.meta.hot) {
    import.meta.hot.on("nuxt-link-checker:connected", () => {
      client.start();
    });
  }
}

import { defineEventHandler, getHeader, readBody } from "h3";
import { fixSlashes } from "site-config-stack/urls";
import { parseURL } from "ufo";
import { resolve } from "pathe";
import { inspect } from "../../../pure/inspect.js";
import { generateFileLinkDiff, generateFileLinkPreviews, lruFsCache } from "../../../pure/diff.js";
import { getLinkResponse } from "../../../pure/crawl.js";
import { isNonFetchableLink } from "../../../pure/inspections/util.js";
import { isInternalRoute } from "../../util.js";
import { useNitroApp, useNitroOrigin, useRuntimeConfig, useSiteConfig } from "#imports";
import { serverQueryContent } from "#content/server";
export default defineEventHandler(async (e) => {
  const { tasks, ids } = await readBody(e);
  const runtimeConfig = useRuntimeConfig().public["nuxt-link-checker"];
  const partialCtx = {
    ids,
    fromPath: fixSlashes(false, parseURL(getHeader(e, "referer") || "/").pathname),
    siteConfig: useSiteConfig(e)
  };
  const extraPaths = [];
  if (serverQueryContent) {
    const contentDocument = await serverQueryContent(e, partialCtx.fromPath).findOne();
    if (contentDocument)
      extraPaths.push(resolve(runtimeConfig.rootDir, "content", contentDocument._file));
  }
  lruFsCache.clear();
  const pageSearch = useNitroApp()._linkCheckerPageSearch;
  return Promise.all(
    tasks.map(async ({ link, paths, textContent }) => {
      if (isNonFetchableLink(link) || isInternalRoute(link))
        return { passes: true };
      const response = await getLinkResponse({
        link,
        timeout: runtimeConfig.fetchTimeout,
        fetchRemoteUrls: runtimeConfig.fetchRemoteUrls,
        baseURL: useNitroOrigin(e),
        isInStorage() {
          return false;
        }
      });
      const result = inspect({
        ...partialCtx,
        link,
        textContent,
        pageSearch,
        response,
        skipInspections: runtimeConfig.skipInspections
      });
      const filePaths = [
        ...extraPaths,
        ...paths.map((p) => {
          const [filepath] = p.split(":");
          return filepath;
        })
      ];
      if (!result.passes) {
        result.sources = (await Promise.all(filePaths.map(async (filepath) => await generateFileLinkPreviews(filepath, link)))).filter((s) => s.previews.length);
        result.diff = await Promise.all((result.sources || []).map(async ({ filepath }) => generateFileLinkDiff(filepath, link, result.fix)));
      }
      return result;
    })
  );
});
